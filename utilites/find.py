find ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

# В отличие от программы locate , выполняющей поиск файлов по именам, 
# программа find ищет файлы согласно заданным атрибутам в указанном 
# каталоге (и во вложенных подкаталогах).

# :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

find ~ | wc -l
# Так как список выводится в стандартный вывод, его можно передать по 
# конвейеру другим программам. Программа wc, подсчитает число файлов

find ~ -type d | wc -l
# Добавив проверку -type d , мы ограничились поиском только каталогов.


# :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
Проверки типов файлов в find

b
# Специальный файл блочного устройства

c
# Специальный файл символьного устройства

d
# Каталог

f
# Обычный файл

l
# Символическая ссылка




# :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
Единицы измерения, поддерживаемые командой find

b
# Блоки размером по 512 байт (используется по умолчанию, если иное не 
# указано явно)

c
# Байты

w
# 2-байтные слова

k
# Килобайты (Kilobytes, блоки по 1024 байт)

M
# Мегабайты (Megabytes, блоки по 1 048 576 байт)

G
# Гигабайты (Gigabytes, блоки по 1 073 741 824 байт)



# :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
Проверки, поддерживаемые командой find

find ~ -type f -name '*.jpg' -size +1M | wc -l
# В этом примере мы добавили проверку -name с шаблоном имени файла. 
# Обратите внимание, что шаблон заключен в кавычки, чтобы предотвратить 
# подстановку имен файлов командной оболочкой. Далее мы добавили проверку 
# -size со строкой +1M . Начальный символ «плюс» указывает, что требуется 
# искать файлы, размер которых превышает указанное число. Начальный символ 
# «минус» изменил бы значение строки на противоположное: «меньше указанного 
# числа». Число без знака означает: «в точности соответствует значению». 
# Буква M в конце определяет единицы измерения – мегабайты (Megabytes).

-cmin n
# Соответствует файлам или каталогам, содержимое или атрибуты которых 
# последний раз изменялись точно n минут назад. Чтобы выразить условие 
# «менее n минут назад», используйте -n; чтобы выразить условие «более n 
# минут назад», используйте +n

-ctime n
# Соответствует файлам или каталогам, содержимое или атрибуты (то есть 
# разрешения) которых последний раз изменялись более чем n*24 часа назад

-empty
# Соответствует пустым файлам и каталогам

-group группа
# Соответствует файлам или каталогам, принадлежащим указанной группе. 
# Группа может задаваться именем или числовым идентификатором группы

-iname шаблон
# Действует так же, как проверка -name, но различает регистр символов

-inum n
# Соответствует файлам с номером индексного узла (inode) n. Эту проверку 
# удобно использовать для поиска всех жестких ссылок на определенный 
# индексный узел

-mmin n
# Соответствует файлам или каталогам, содержимое которых последний раз 
# изменялось n минут назад

-mtime n
# Соответствует файлам или каталогам, содержимое которых последний раз 
# изменялось n*24 часов назад

-name шаблон
# Соответствует файлам и каталогам, имена которых совпадают с указанным 
# шаблоном

-newer имя
# Соответствует файлам и каталогам, содержимое которых последний раз 
# изменялось позже, чем у файла с указанным именем. Эта проверка может 
# пригодиться в сценариях, выполняющих резервное копирование файлов. Каждый 
# раз в процессе создания резервной копии можно обновлять файл (например, 
# файл журнала) и затем с помощью find определять, какие файлы изменились 
# с момента последнего обновления

-nouser
# Соответствует файлам и каталогам, не принадлежащим какому-либо допустимому 
# пользователю. Эту проверку можно использовать для поиска файлов, 
# принадлежащих удаленным учетным записям, или для обнаружения следов 
# злоумышленников

-nogroup
# Соответствует файлам и каталогам, не принадлежащим какой-либо допустимой 
# группе

-perm режим
# Соответствует файлам или каталогам с указанным режимом доступа. Режим 
# может выражаться восьмеричным числом или иметь символическую форму

-samefile имя
# Действует так же, как проверка -inum. Соответствует файлам с тем же 
# номером индексного узла (inode), что и файл с указанным именем

-size n
# Соответствует файлам с размером n

-type c
# Соответствует файлам с типом c

-user имя
# Соответствует файлам или каталогам, принадлежащим пользователю с 
# указанным именем . Аргумент имя может быть именем или числовым 
# идентификатором пользователя





# :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
Логические операторы, поддерживаемые командой find

find ~ \( -type f -not -perm 0600 \) -or \( -type d -not -perm 0700 \)
# выполнит поиск всех файлов с разрешениями, отличающимися от 0600, и каталогов 
# с разрешениями, отличающимися от 0700

-and
# Соответствует, если выполняются условия в проверках с обеих сторон от 
# оператора. Можно сократить до -a. Обратите внимание, что в отсутствие 
# операторов по умолчанию подразумевается -and

-or
# Соответствует, если выполняется условие с одной из сторон от оператора. Можно 
# сократить до -o

-not
# Соответствует, если условие в проверке, следующей за оператором, не 
# выполняется. Можно сократить до -!

()
# Группируют проверки и операторы для формирования крупных выражений. 
# Используются для управления порядком проверок. По умолчанию проверки
# выполняются слева направо. Часто используются для изменения порядка проверок 
# по умолчанию, чтобы получить желаемый результат. Даже если скобки не нужны, 
# иногда полезно включать их, чтобы сделать команды более наглядными. Не 
# забывайте, что круглые скобки имеют специальное значение для командной 
# оболочки, поэтому их нужно экранировать, чтобы они передавались команде find 
# как аргументы. Обычно экранирование выполняют с помощью символа обратного слеша



# ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
Предопределенные операции, поддерживаемые командой find

-delete
# Удаляет текущий найденный файл

-ls
# Действует эквивалентно команде ls -dils в отношении найденного файла. 
# Результат выводится в стандартный вывод

-print
# Выводит полный путь к найденному файлу в стандартный вывод. Эта операция 
# выполняется по умолчанию, если не указана никакая другая

-quit
# Завершает выполнение команды после обнаружения первого совпадения




# ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
Параметры команды find

-depth
# Требует от find обработать сначала файлы в каталогах и только потом каталоги. 
# Этот параметр автоматически применяется с операцией -delete

-maxdepth число_уровней
# Устанавливает максимальное число уровней, на которое команда find может 
# опускаться в дереве каталогов, выполняя проверки и операции

-mindepth число_уровней
# Устанавливает минимальное число уровней, на которое команда find должна 
# опуститься в дереве каталогов перед выполнением проверок и операций

-mount
# Требует от find не выполнять обход каталогов, в которые смонтированы другие 
# файловые системы

-noleaf
# Требует от find не оптимизировать поиск, опираясь на предположение, что поиск 
# ведется в Unix-подобной файловой системе. Этот параметр необходимо 
# использовать при обходе файловых систем DOS/Windows CD-ROM





# ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
example

find ~ -type f -name '*.less' | xargs ls
# Здесь вывод команды find передается по конвейеру команде xargs , которая, в 
# свою очередь, конструирует список аргументов для команды ls и выполняет ее

find ~ -type f -name '*.BAK' -delete
# Эта команда найдет в домашнем каталоге (и во вложенных подкаталогах) 
# пользователя все файлы с расширением .BAK и удалит их

find ~ -iname '*.jpg' -print0 | xargs --null ls -l
# Этот прием гарантирует правильную обработку любых имен файлов, даже 
# содержащих пробелы.
# Unix-подобные системы позволяют встраивать в имена файлов пробелы (и даже 
# символы перевода строки). Это порождает проблемы при выполнении программ, 
# таких как xargs, конструирующих списки аргументов для других программ. 
# Внутренние пробелы интерпретируются как разделители, и получившаяся команда 
# будет интерпретировать слова, разделенные пробелами, как отдельные аргументы. 
# Для решения этой проблемы find и xarg предлагают использовать в качестве 
# разделителя аргументов пустой символ (null character). В кодировке ASCII 
# пустой символ определен как символ с нулевым кодом (в противоположность 
# пробелу, например, который в кодировке ASCII определен как символ с кодом 32). 
# Команда find поддерживает операцию -print0, которая производит вывод имен 
# файлов, разделенных пустым символом, а команда xargs имеет параметр --null,
# позволяющий организовать прием значений, разделенных пустым символом.

